# Radix-4 非恢复 SRT 除法器架构设计

## 1. 算法概述

### 1.1 Radix-4 SRT 除法原理

Radix-4 SRT（Sweeney-Robertson-Tocher）除法是一种高效的除法算法，每次迭代产生 2 位商数字。

**递归关系**：
```
P_{i+1} = 4 * P_i - q_i * D
```

其中：
- P_i：第 i 次迭代的余数（冗余表示，可以为负）
- q_i：第 i 次迭代的商数字（q_i ∈ {-2, -1, 0, +1, +2}）
- D：除数

**关键特性**：
- 非恢复：余数 P_i 允许为负，不进行恢复操作
- 冗余表示：商数字集合 {-2, -1, 0, +1, +2} 允许快速收敛
- 每次迭代产生 2 位商，比 radix-2 快一倍

### 1.2 商数字选择表设计

商数字选择基于部分余数 P_i 和除数 D 的最高位。

**采样位数**：
- 余数 P_i：使用最高 5 位（符号位 + 4 位数值）
- 除数 D：使用最高 3 位（符号位 + 2 位数值）

**选择表**（基于 P_i[4:0] 和 D[2:0]）：

| P_i[4:0] | D[2:0] | q_i |
|----------|--------|----|
| -16 ~ -9 | 任意 | -2 |
| -8 ~ -5 | 任意 | -1 |
| -4 ~ -1 | 任意 | 0 |
| 0 ~ 3 | 任意 | 0 |
| 4 ~ 7 | 任意 | +1 |
| 8 ~ 15 | 任意 | +2 |

**简化选择逻辑**（使用比较）：
```
if P_i[4] == 1 (负数):
    if P_i[3:0] >= 0b1100 (<= -4): q_i = -2
    elif P_i[3:0] >= 0b1011 (<= -5): q_i = -1
    else: q_i = 0
else (正数):
    if P_i[3:0] >= 0b0100 (>= 4): q_i = +2
    elif P_i[3:0] >= 0b0001 (>= 1): q_i = +1
    else: q_i = 0
```

### 1.3 收敛性保证

**约束条件**：
```
|P_{i+1}| < 2*D
```

这个约束保证了算法的收敛性，通过适当选择 q_i 来满足。

**商数字编码**（3 位有符号）：
```
-2: 110 (二进制补码)
-1: 111
 0: 000
+1: 001
+2: 010
```

## 2. 硬件架构

### 2.1 状态机设计

**状态定义**：
- `IDLE`：空闲，等待新的除法指令
- `INIT`：初始化，保存操作数，设置初始余数
- `ITERATE`：迭代，执行 radix-4 迭代
- `FINAL_CORRECTION`：最终修正，将冗余商转换为标准二进制
- `DONE`：完成，结果有效

**状态转换**：
```
IDLE -> INIT: 当收到除法指令且除法器空闲时
INIT -> ITERATE: 初始化完成
ITERATE -> ITERATE: 继续迭代（迭代计数 < 16）
ITERATE -> FINAL_CORRECTION: 迭代完成（迭代计数 = 16）
FINAL_CORRECTION -> DONE: 修正完成
DONE -> IDLE: 结果已被读取
```

### 2.2 寄存器设计

| 寄存器 | 位宽 | 描述 |
|--------|------|------|
| `div_state` | 3 | 除法器状态 |
| `div_op` | 2 | 操作类型（00=DIV, 01=DIVU, 10=REM, 11=REMU）|
| `div_dividend` | 32 | 被除数 |
| `div_divisor` | 32 | 除数 |
| `div_remainder` | 34 | 余数（扩展到 34 位，防止溢出）|
| `div_quotient` | 32 | 商（冗余表示）|
| `div_iter_count` | 5 | 迭代计数器（0-16）|
| `div_sign` | 1 | 结果符号（用于有符号除法）|
| `div_neg_result` | 1 | 结果是否需要取负（用于有符号除法）|
| `div_done` | 1 | 完成标志 |
| `div_result` | 32 | 最终结果 |
| `div_rd` | 5 | 目标寄存器 |
| `div_control` | 45 | 控制信号 |
| `div_pc` | 32 | 指令 PC |

### 2.3 周期计数分析

**总周期数**：18 周期

**周期分解**：
1. **Cycle 1 (INIT)**：初始化
   - 保存操作数
   - 处理符号（有符号除法）
   - 设置初始余数
   - 检查除零
   - 设置迭代计数器 = 0

2. **Cycle 2-17 (ITERATE)**：16 次迭代
   - 每次迭代执行：
     - 商数字选择（基于查找表）
     - 余数更新：P_{i+1} = 4 * P_i - q_i * D
     - 商累积：Q = Q + q_i << (2*i)
     - 迭代计数器 + 1

3. **Cycle 18 (FINAL_CORRECTION)**：最终修正
   - 将冗余商转换为标准二进制
   - 应用符号修正
   - 选择商或余数
   - 设置完成标志

**固定延迟**：一旦开始，除法器总是占用 18 个周期。

## 3. 算法细节

### 3.1 初始化阶段

**无符号除法（DIVU, REMU）**：
```
P_0 = dividend
D = divisor
sign = 0
```

**有符号除法（DIV, REM）**：
```
if dividend < 0:
    P_0 = -dividend
    sign = sign XOR 1
if divisor < 0:
    D = -divisor
    sign = sign XOR 1
```

**除零检测**：
```
if D == 0:
    quotient = 0xFFFFFFFF (对于 DIV)
    quotient = 0xFFFFFFFF (对于 DIVU)
    remainder = dividend (对于 REM)
    remainder = dividend (对于 REMU)
    直接跳转到 DONE
```

### 3.2 迭代阶段

**商数字选择**：
```
q_i = select_quotient_digit(P_i[4:0], D[2:0])
```

**余数更新**：
```
P_{i+1} = (P_i << 2) - (q_i * D)
```

**商累积**：
```
Q = Q + (q_i << (2*i))
```

**迭代计数**：
```
iter_count = iter_count + 1
```

### 3.3 最终修正阶段

**冗余商转换**：
```
Q_corrected = Q
for i from 0 to 15:
    if Q[i*2+1:i*2*2] == 0b10:  # -2
        Q_corrected = Q_corrected - (1 << (2*i+2))
    elif Q[i*2+1:i*2*2] == 0b11:  # -1
        Q_corrected = Q_corrected - (1 << (2*i+1))
```

**符号修正**：
```
if sign == 1:
    Q_corrected = -Q_corrected
```

**结果选择**：
```
if op == DIV or op == DIVU:
    result = Q_corrected
else:  # REM or REMU
    result = P_16 (最终余数)
```

## 4. 流水线集成

### 4.1 EX 阶段集成

除法器作为 EX 阶段的一个长延迟执行单元，类似于乘法器。

**接口信号**：
- `div_start`：启动除法
- `div_busy`：除法器忙
- `div_done`：除法完成
- `div_result`：除法结果

**控制逻辑**：
```
if 除法指令到达 EX 阶段 and div_busy == 0:
    启动除法器
    暂停流水线（stall = 1）
if div_done == 1:
    传递结果到 MEM 阶段
    清除暂停（stall = 0）
```

### 4.2 冒险处理

**数据冒险**：
- 当除法器执行时，任何依赖于除法结果的指令必须暂停
- 使用 HazardUnit 检测这种冒险

**控制冒险**：
- 除法指令不会改变 PC，因此没有控制冒险

### 4.3 暂停逻辑

```
div_stall = (div_cycle != 0) & (EX 阶段有除法指令)
stall = div_stall | other_stall_conditions
```

## 5. 指令支持

### 5.1 DIV（有符号除法）

```
功能：有符号除法
操作：rd = rs1 / rs2
特殊情况：
    - 除数为 0：rd = -1
    - 除法溢出（-2^31 / -1）：rd = -2^31
```

### 5.2 DIVU（无符号除法）

```
功能：无符号除法
操作：rd = rs1 / rs2
特殊情况：
    - 除数为 0：rd = 0xFFFFFFFF
```

### 5.3 REM（有符号取余）

```
功能：有符号取余
操作：rd = rs1 % rs2
特殊情况：
    - 除数为 0：rd = rs1
    - 除法溢出（-2^31 / -1）：rd = 0
```

### 5.4 REMU（无符号取余）

```
功能：无符号取余
操作：rd = rs1 % rs2
特殊情况：
    - 除数为 0：rd = rs1
```

## 6. 性能分析

### 6.1 延迟

- **除法延迟**：18 周期
- **乘法延迟**：3 周期
- **ALU 延迟**：1 周期

### 6.2 吞吐量

- **除法吞吐量**：1 条指令 / 18 周期
- **乘法吞吐量**：1 条指令 / 3 周期
- **ALU 吞吐量**：1 条指令 / 1 周期

### 6.3 资源使用

- **除法器**：约 500-1000 LUT（取决于实现）
- **乘法器**：约 300-500 LUT
- **ALU**：约 100-200 LUT

## 7. 验证策略

### 7.1 功能验证

- 测试所有 4 条除法指令
- 测试边界情况（除零、溢出）
- 测试随机输入

### 7.2 性能验证

- 测量实际周期数
- 验证固定延迟

### 7.3 正确性验证

- 与软件除法结果比较
- 验证商和余数的关系：dividend = quotient * divisor + remainder
